# app.py (Flask Backend)

from flask import Flask, request, jsonify, send_file, Response, render_template # Import render_template
from flask_cors import CORS
import os
import io
import csv
from functools import wraps
import base64 # Import base64 for basic authentication decoding
from datetime import datetime # For timestamping
import re # Import regex module

# Initialize Flask app without specifying static_folder if you only serve templates
# or keep it if you still have other static assets like CSS/JS in a 'static' folder.
# For this change, we'll assume index.html is the only file being served directly.
app = Flask(__name__) # Removed static_folder and static_url_path for template serving

CORS(app) # Enable CORS for your frontend

# --- Data Storage Configuration ---
# The CSV file where IDs will be stored.
DATA_FILE = 'generated_ids.csv'

# --- Admin Authentication (Basic Auth for demonstration) ---
# In a real application, use a more robust authentication method (e.g., Firebase Auth tokens)
ADMIN_USERNAME = os.environ.get('ADMIN_USERNAME', 'admin')
ADMIN_PASSWORD = os.environ.get('ADMIN_PASSWORD', 'securepassword') # CHANGE THIS IN PRODUCTION!
# IMPORTANT SECURITY NOTE: Hardcoding credentials like this, even if loaded from
# environment variables, is not ideal for production. For a truly secure system,
# implement a proper admin login system with hashed passwords and token-based
# authentication (e.g., JWTs) rather than Basic Auth.

def authenticate_admin(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        auth_header = request.headers.get('Authorization')
        if not auth_header:
            return Response('Authentication Required', 401, {'WWW-Authenticate': 'Basic realm="Login Required"'})

        try:
            auth_type, auth_info = auth_header.split(None, 1)
            if auth_type.lower() == 'basic':
                decoded = base64.b64decode(auth_info).decode('utf-8')
                username, password = decoded.split(':', 1)
                if username == ADMIN_USERNAME and password == ADMIN_PASSWORD:
                    return f(*args, **kwargs)
        except Exception as e:
            print(f"Authentication error: {e}")

        return Response('Invalid Credentials', 401, {'WWW-Authenticate': 'Basic realm="Login Required"'})
    return decorated

# --- Helper function to read all existing IDs from the CSV file ---
def get_existing_ids_from_csv():
    existing_ids_data = []
    if os.path.exists(DATA_FILE):
        with open(DATA_FILE, mode='r', newline='', encoding='utf-8') as file:
            reader = csv.DictReader(file)
            for row in reader:
                existing_ids_data.append(row)
    return existing_ids_data

# --- Route to serve the HTML frontend from templates ---
@app.route('/')
def serve_index():
    # This will now serve the index.html file from the 'templates' directory
    return render_template('index.html')

# --- API Endpoint for ID Generation ---
@app.route('/generate-id', methods=['POST'])
def generate_id():
    data = request.get_json()
    phone = data.get('phone', '').strip()
    email = data.get('email', '').strip()
    client_user_id = request.headers.get('X-User-ID', 'anonymous') # Get the unique client ID

    # --- Server-side Validation ---
    # UAE Phone Number Regex: Covers common formats like +97150xxxxxxx, 0097150xxxxxxx, 050xxxxxxx,
    # and landlines (02, 03, 04, 06, 07, 09).
    uae_phone_regex = re.compile(r"^(?:\+971|00971|0)?(?:5[0-9]|2|3|4|6|7|8|9)\d{7}$")
    if not uae_phone_regex.match(phone):
        return jsonify({"error": "Invalid UAE phone number format. E.g., +971501234567 or 0501234567."}), 400

    # Email Regex: Basic email format validation
    email_regex = re.compile(r"^[^\s@]+@[^\s@]+\.[^\s@]+$")
    if not email_regex.match(email):
        return jsonify({"error": "Invalid email address format."}), 400

    try:
        existing_ids_data = get_existing_ids_from_csv()
        existing_ids_set = {row['ID'] for row in existing_ids_data if 'ID' in row}

        # --- Check for duplicate Phone Number, Email ID, and X-User-ID ---
        for row in existing_ids_data:
            if row.get('Phone') == phone:
                return jsonify({"error": f"Phone number {phone} already exists."}), 409 # Conflict
            if row.get('Email') == email:
                return jsonify({"error": f"Email ID {email} already exists."}), 409 # Conflict
            # New check: If X-User-ID already exists in 'Generated By' column
            if row.get('Generated By') == client_user_id:
                return jsonify({"error": "You can put only one Slot for draw"}), 409 # Conflict

        new_id_number = None
        for i in range(1001): # Iterate from 0 to 1000 (inclusive)
            potential_id = f'VIVOX200FE{str(i).zfill(4)}'
            if potential_id not in existing_ids_set:
                new_id_number = i
                break

        if new_id_number is None:
            return jsonify({"error": "All IDs in the range VIVOX200FE0000-VIVOX200FE1000 have been used."}), 500

        generated_id = f'VIVOX200FE{str(new_id_number).zfill(4)}'
        
        # Prepare the new record
        new_record = {
            'ID': generated_id,
            'Phone': phone,
            'Email': email,
            'Generated At': datetime.now().isoformat(),
            'Generated By': client_user_id # Use the unique client ID
        }

        # Append the new record to the CSV file
        file_exists = os.path.exists(DATA_FILE)
        with open(DATA_FILE, mode='a', newline='', encoding='utf-8') as file:
            fieldnames = ['ID', 'Phone', 'Email', 'Generated At', 'Generated By']
            writer = csv.DictWriter(file, fieldnames=fieldnames)

            if not file_exists or os.stat(DATA_FILE).st_size == 0: # Write header only if file is new or empty
                writer.writeheader()
            writer.writerow(new_record)

        return jsonify({"id": generated_id}), 200

    except Exception as e:
        print(f"Error generating or storing ID: {e}")
        return jsonify({"error": f"Failed to generate or store ID: {str(e)}"}), 500

# --- Admin API Endpoint to Download IDs as CSV ---
@app.route('/admin/download-ids', methods=['GET'])
@authenticate_admin
def download_ids_csv():
    try:
        all_ids_data = get_existing_ids_from_csv()

        if not all_ids_data:
            return jsonify({"message": "No IDs found to download."}), 200

        # Prepare CSV in memory
        output = io.StringIO()
        fieldnames = ['ID', 'Phone', 'Email', 'Generated At', 'Generated By']
        writer = csv.DictWriter(output, fieldnames=fieldnames)

        writer.writeheader()
        writer.writerows(all_ids_data)

        output.seek(0) # Go to the beginning of the stream

        return send_file(
            io.BytesIO(output.getvalue().encode('utf-8')),
            mimetype='text/csv',
            as_attachment=True,
            download_name='generated_ids.csv'
        )

    except Exception as e:
        print(f"Error downloading IDs: {e}")
        return jsonify({"error": f"Failed to download IDs: {str(e)}"}), 500

if __name__ == '__main__':
    # For development, you might run this directly.
    # For production, use a WSGI server like Gunicorn (e.g., gunicorn app:app).
    # Ensure debug=True is ONLY for development, never in production.
    app.run(debug=True, port=5000) # Run on port 5000 by default
